{"version":3,"sources":["../../src/pages/plants/plants.module.ts","../../node_modules/ionic-image-loader/dist/providers/image-loader-config.js","../../node_modules/ionic-image-loader/dist/providers/image-loader.js","../../node_modules/ionic-image-loader/dist/components/img-loader.js","../../node_modules/ionic-image-loader/dist/index.js","../../node_modules/ionic-image-loader/dist/image-loader.module.js","../../node_modules/rxjs/add/operator/first.js","../../node_modules/rxjs/operator/first.js","../../src/pages/plants/plants.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAyC;AACa;AACN;AACM;AACgB;AAEhC;AAgBtC;IAAA;IAAgC,CAAC;IAApB,gBAAgB;QAd5B,uEAAQ,CAAC;YACR,YAAY,EAAE;gBACZ,2DAAU;aACX;YACD,OAAO,EAAE;gBACP,sEAAe,CAAC,QAAQ,CAAC,2DAAU,CAAC;gBACpC,4EAAe,CAAC,QAAQ,EAAE;gBAC1B,4EAAgB;gBAChB,uFAAgB;aACjB;YACD,OAAO,EAAE;gBACP,2DAAU;aACX;SACF,CAAC;OACW,gBAAgB,CAAI;IAAD,uBAAC;CAAA;AAAJ;;;;;;;;;ACtB7B;AAAA;AAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,OAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO,iBAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA;AACA;AACA,CAAC;AAC4B;AAC7B;AACA,KAAK,OAAO,iEAAU,EAAE;AACxB;AACA;AACA,gDAAgD,WAAW;AAC3D,+C;;;;;;;;AC3LA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA2C;AACD;AACQ;AACK;AACG;AACJ;AACrB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4EAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,mBAAmB,gEAAI;AACvB,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,wBAAwB,OAAO;AAC/B,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,gBAAgB,EAAE;AAC9D;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,oEAAoE,gBAAgB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,+BAA+B,2BAA2B,EAAE;AAC5D;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA,uDAAuD,0CAA0C,EAAE;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,oCAAoC,iEAAiE,EAAE;AACvG;AACA;AACA,sEAAsE,mCAAmC,EAAE;AAC3G;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iBAAiB,EAAE;AAC9D,4CAA4C,iBAAiB,EAAE,EAAE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2EAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,+BAA+B;AAC/B,SAAS;AACT;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO;AAChC,iBAAiB,2BAA2B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B,iBAAiB,kCAAkC;AACnD;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gGAAgG,EAAE;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,+FAA+F,EAAE;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,CAAC;AACsB;AACvB;AACA,KAAK,OAAO,iEAAU,EAAE;AACxB;AACA;AACA,0CAA0C;AAC1C,KAAK,OAAO,+EAAiB,GAAG;AAChC,KAAK,OAAO,gEAAI,GAAG;AACnB,KAAK,OAAO,wEAAU,GAAG;AACzB,KAAK,OAAO,+DAAQ,GAAG;AACvB,EAAE;AACF,wC;;;;;;;;AChlBA;AAAA;AAAA;AAAA;AAA6F;AACrC;AACa;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mEAAY;AACpC;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iCAAiC,EAAE;AAC1E,qCAAqC,sDAAsD,EAAE;AAC7F;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA,qCAAqC,oBAAoB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0EAA0E,qFAAqF,EAAE;AACjK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACoB;AACrB;AACA,KAAK,OAAO,gEAAS;AACrB;AACA;AACA;AACA,uCAAuC,aAAa,mBAAmB,oBAAoB,gBAAgB,EAAE;AAC7G,aAAa,IAAI;AACjB;AACA;AACA,wCAAwC;AACxC,KAAK,OAAO,iEAAU,GAAG;AACzB,KAAK,OAAO,+DAAQ,GAAG;AACvB,KAAK,OAAO,4EAAW,GAAG;AAC1B,KAAK,OAAO,yFAAiB,GAAG;AAChC,EAAE;AACF;AACA,qBAAqB,OAAO,4DAAK,uBAAuB;AACxD,iBAAiB,OAAO,4DAAK,EAAE;AAC/B,+BAA+B,OAAO,4DAAK,EAAE;AAC7C,gBAAgB,OAAO,4DAAK,EAAE;AAC9B,uBAAuB,OAAO,4DAAK,4BAA4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","file":"16.js","sourcesContent":["import { NgModule } from '@angular/core';\nimport { TranslateModule } from '@ngx-translate/core';\nimport { IonicPageModule } from 'ionic-angular';\nimport { IonicImageLoader } from 'ionic-image-loader';\nimport { DirectivesModule } from '../../directives/directives.module';\n\nimport { PlantsPage } from './plants';\n\n@NgModule({\n  declarations: [\n    PlantsPage,\n  ],\n  imports: [\n    IonicPageModule.forChild(PlantsPage),\n    TranslateModule.forChild(),\n    IonicImageLoader,\n    DirectivesModule\n  ],\n  exports: [\n    PlantsPage\n  ]\n})\nexport class PlantsPageModule { }\n\n\n\n// WEBPACK FOOTER //\n// ./src/pages/plants/plants.module.ts","import { Injectable } from '@angular/core';\nvar ImageLoaderConfig = (function () {\n    function ImageLoaderConfig() {\n        this.debugMode = false;\n        this.spinnerEnabled = true;\n        this.fallbackAsPlaceholder = false;\n        this.backgroundSize = 'contain';\n        this.backgroundRepeat = 'no-repeat';\n        this.display = 'block';\n        this.width = '100%';\n        this.height = '100%';\n        this.useImg = false;\n        this.concurrency = 5;\n        this.maxCacheSize = -1;\n        this.maxCacheAge = -1;\n        this.imageReturnType = 'uri';\n        this.fileNameCachedWithExtension = false;\n        this.fallbackFileNameCachedExtension = '.jpg';\n        this._cacheDirectoryName = 'image-loader-cache';\n    }\n    Object.defineProperty(ImageLoaderConfig.prototype, \"cacheDirectoryName\", {\n        get: function () {\n            return this._cacheDirectoryName;\n        },\n        set: function (name) {\n            name.replace(/\\W/g, '');\n            this._cacheDirectoryName = name;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Enables debug mode to receive console logs, errors, warnings\n     */\n    ImageLoaderConfig.prototype.enableDebugMode = function () {\n        this.debugMode = true;\n    };\n    /**\n     * Enable/Disable the spinner by default. Defaults to true.\n     * @param enable {boolean} set to true to enable\n     */\n    ImageLoaderConfig.prototype.enableSpinner = function (enable) {\n        this.spinnerEnabled = enable;\n    };\n    /**\n     * Enable/Disable the fallback image as placeholder instead of the spinner. Defaults to false.\n     * @param enable {boolean} set to true to enable\n     */\n    ImageLoaderConfig.prototype.enableFallbackAsPlaceholder = function (enable) {\n        this.fallbackAsPlaceholder = enable;\n    };\n    /**\n     * Sets the cache directory name. Defaults to 'image-loader-cache'\n     * @param name {string} name of directory\n     */\n    ImageLoaderConfig.prototype.setCacheDirectoryName = function (name) {\n        this.cacheDirectoryName = name;\n    };\n    /**\n     * Set default height for images that are not using <img> tag\n     * @param height {string} height\n     */\n    ImageLoaderConfig.prototype.setHeight = function (height) {\n        this.height = height;\n    };\n    /**\n     * Set default width for images that are not using <img> tag\n     * @param width {string} Width\n     */\n    ImageLoaderConfig.prototype.setWidth = function (width) {\n        this.width = width;\n    };\n    /**\n     * Enable display mode for images that are not using <img> tag\n     * @param display {string} Display mode\n     */\n    ImageLoaderConfig.prototype.setDisplay = function (display) {\n        this.display = display;\n    };\n    /**\n     * Use <img> tag by default\n     * @param use {boolean} set to true to use <img> tag by default\n     */\n    ImageLoaderConfig.prototype.useImageTag = function (use) {\n        this.useImg = use;\n    };\n    /**\n     * Set default background size for images that are not using <img> tag\n     * @param backgroundSize {string} Background size\n     */\n    ImageLoaderConfig.prototype.setBackgroundSize = function (backgroundSize) {\n        this.backgroundSize = backgroundSize;\n    };\n    /**\n     * Set background repeat for images that are not using <img> tag\n     * @param backgroundRepeat {string} Background repeat\n     */\n    ImageLoaderConfig.prototype.setBackgroundRepeat = function (backgroundRepeat) {\n        this.backgroundRepeat = backgroundRepeat;\n    };\n    /**\n     * Set fallback URL to use when image src is undefined or did not resolve.\n     * This image will not be cached. This should ideally be a locally saved image.\n     * @param fallbackUrl {string} The remote or local URL of the image\n     */\n    ImageLoaderConfig.prototype.setFallbackUrl = function (fallbackUrl) {\n        this.fallbackUrl = fallbackUrl;\n    };\n    /**\n     * Set the maximum number of allowed connections at the same time.\n     * @param concurrency\n     */\n    ImageLoaderConfig.prototype.setConcurrency = function (concurrency) {\n        this.concurrency = concurrency;\n    };\n    /**\n     * Sets the maximum allowed cache size\n     * @param cacheSize {number} Cache size in bytes\n     */\n    ImageLoaderConfig.prototype.setMaximumCacheSize = function (cacheSize) {\n        this.maxCacheSize = cacheSize;\n    };\n    /**\n     * Sets the maximum allowed cache age\n     * @param cacheAge {number} Maximum cache age in milliseconds\n     */\n    ImageLoaderConfig.prototype.setMaximumCacheAge = function (cacheAge) {\n        this.maxCacheAge = cacheAge;\n    };\n    /**\n     * Set the return type of cached images\n     * @param imageReturnType {string} The return type; either 'base64' or 'uri'\n     */\n    ImageLoaderConfig.prototype.setImageReturnType = function (imageReturnType) {\n        this.imageReturnType = imageReturnType;\n    };\n    /**\n     * Set the default spinnern ame\n     * @param name\n     */\n    ImageLoaderConfig.prototype.setSpinnerName = function (name) {\n        this.spinnerName = name;\n    };\n    /**\n     * Set the default spinner color\n     * @param color\n     */\n    ImageLoaderConfig.prototype.setSpinnerColor = function (color) {\n        this.spinnerColor = color;\n    };\n    /**\n     * Set headers options for the HttpClient transfers.\n     * @param headers\n     */\n    ImageLoaderConfig.prototype.setHttpHeaders = function (headers) {\n        this.httpHeaders = headers;\n    };\n    /**\n     * Set options for the FileTransfer plugin\n     * @param options\n     * @deprecated FileTransfer plugin removed.\n     */\n    ImageLoaderConfig.prototype.setFileTransferOptions = function (options) {\n        // do nothing, plugin deprecated.\n    };\n    /**\n     * Enable/Disable the save filename of cached images with extension.  Defaults to false.\n     * @param enable {boolean} set to true to enable\n     */\n    ImageLoaderConfig.prototype.setFileNameCachedWithExtension = function (enable) {\n        this.fileNameCachedWithExtension = enable;\n    };\n    /**\n     * Set fallback extension filename of cached images.  Defaults to '.jpg'.\n     * @param extension {string} fallback extension (e.x .jpg)\n     */\n    ImageLoaderConfig.prototype.setFallbackFileNameCachedExtension = function (extension) {\n        this.fallbackFileNameCachedExtension = extension;\n    };\n    return ImageLoaderConfig;\n}());\nexport { ImageLoaderConfig };\nImageLoaderConfig.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nImageLoaderConfig.ctorParameters = function () { return []; };\n//# sourceMappingURL=image-loader-config.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ionic-image-loader/dist/providers/image-loader-config.js\n// module id = 515\n// module chunks = 0 16","import { Injectable } from '@angular/core';\nimport { File } from '@ionic-native/file';\nimport { HttpClient } from '@angular/common/http';\nimport { normalizeURL, Platform } from 'ionic-angular';\nimport { ImageLoaderConfig } from './image-loader-config';\nimport { fromEvent } from 'rxjs/observable/fromEvent';\nimport 'rxjs/add/operator/first';\nvar ImageLoader = (function () {\n    function ImageLoader(config, file, http, platform) {\n        var _this = this;\n        this.config = config;\n        this.file = file;\n        this.http = http;\n        this.platform = platform;\n        /**\n         * Indicates if the cache service is ready.\n         * When the cache service isn't ready, images are loaded via browser instead.\n         * @type {boolean}\n         */\n        this.isCacheReady = false;\n        /**\n         * Indicates if this service is initialized.\n         * This service is initialized once all the setup is done.\n         * @type {boolean}\n         */\n        this.isInit = false;\n        /**\n         * Number of concurrent requests allowed\n         * @type {number}\n         */\n        this.concurrency = 5;\n        /**\n         * Queue items\n         * @type {Array}\n         */\n        this.queue = [];\n        this.processing = 0;\n        /**\n         * Fast accessable Object for currently processing items\n         */\n        this.currentlyProcessing = {};\n        this.cacheIndex = [];\n        this.currentCacheSize = 0;\n        this.indexed = false;\n        if (!platform.is('cordova')) {\n            // we are running on a browser, or using livereload\n            // plugin will not function in this case\n            this.isInit = true;\n            this.throwWarning('You are running on a browser or using livereload, IonicImageLoader will not function, falling back to browser loading.');\n        }\n        else {\n            fromEvent(document, 'deviceready').first().subscribe(function (res) {\n                if (_this.nativeAvailable) {\n                    _this.initCache();\n                }\n                else {\n                    // we are running on a browser, or using livereload\n                    // plugin will not function in this case\n                    _this.isInit = true;\n                    _this.throwWarning('You are running on a browser or using livereload, IonicImageLoader will not function, falling back to browser loading.');\n                }\n            });\n        }\n    }\n    Object.defineProperty(ImageLoader.prototype, \"nativeAvailable\", {\n        get: function () {\n            return File.installed();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImageLoader.prototype, \"isCacheSpaceExceeded\", {\n        get: function () {\n            return this.config.maxCacheSize > -1 && this.currentCacheSize > this.config.maxCacheSize;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImageLoader.prototype, \"isWKWebView\", {\n        get: function () {\n            return this.platform.is('ios') && window.webkit && window.webkit.messageHandlers;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImageLoader.prototype, \"isIonicWKWebView\", {\n        get: function () {\n            return this.isWKWebView && (location.host === 'localhost:8080' || window.LiveReload);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImageLoader.prototype, \"isDevServer\", {\n        get: function () {\n            return (window['IonicDevServer'] != undefined);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImageLoader.prototype, \"canProcess\", {\n        /**\n         * Check if we can process more items in the queue\n         * @returns {boolean}\n         */\n        get: function () {\n            return (this.queue.length > 0\n                && this.processing < this.concurrency);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Preload an image\n     * @param imageUrl {string} Image URL\n     * @returns {Promise<string>} returns a promise that resolves with the cached image URL\n     */\n    ImageLoader.prototype.preload = function (imageUrl) {\n        return this.getImagePath(imageUrl);\n    };\n    /**\n     * Clears the cache\n     */\n    ImageLoader.prototype.clearCache = function () {\n        var _this = this;\n        if (!this.platform.is('cordova'))\n            return;\n        var clear = function () {\n            if (!_this.isInit) {\n                // do not run this method until our service is initialized\n                setTimeout(clear.bind(_this), 500);\n                return;\n            }\n            // pause any operations\n            _this.isInit = false;\n            _this.file.removeRecursively(_this.file.cacheDirectory, _this.config.cacheDirectoryName)\n                .then(function () {\n                if (_this.isWKWebView && !_this.isIonicWKWebView) {\n                    // also clear the temp files\n                    _this.file.removeRecursively(_this.file.tempDirectory, _this.config.cacheDirectoryName)\n                        .catch(function (error) {\n                        // Noop catch. Removing the tempDirectory might fail,\n                        // as it is not persistent.\n                    })\n                        .then(function () {\n                        _this.initCache(true);\n                    });\n                }\n                else {\n                    _this.initCache(true);\n                }\n            })\n                .catch(_this.throwError.bind(_this));\n        };\n        clear();\n    };\n    /**\n     * Gets the filesystem path of an image.\n     * This will return the remote path if anything goes wrong or if the cache service isn't ready yet.\n     * @param imageUrl {string} The remote URL of the image\n     * @returns {Promise<string>} Returns a promise that will always resolve with an image URL\n     */\n    ImageLoader.prototype.getImagePath = function (imageUrl) {\n        var _this = this;\n        if (typeof imageUrl !== 'string' || imageUrl.length <= 0) {\n            return Promise.reject('The image url provided was empty or invalid.');\n        }\n        return new Promise(function (resolve, reject) {\n            var getImage = function () {\n                if (_this.isImageUrlRelative(imageUrl)) {\n                    resolve(imageUrl);\n                }\n                else {\n                    _this.getCachedImagePath(imageUrl)\n                        .then(resolve)\n                        .catch(function () {\n                        // image doesn't exist in cache, lets fetch it and save it\n                        _this.addItemToQueue(imageUrl, resolve, reject);\n                    });\n                }\n            };\n            var check = function () {\n                if (_this.isInit) {\n                    if (_this.isCacheReady) {\n                        getImage();\n                    }\n                    else {\n                        _this.throwWarning('The cache system is not running. Images will be loaded by your browser instead.');\n                        resolve(imageUrl);\n                    }\n                }\n                else {\n                    setTimeout(function () { return check(); }, 250);\n                }\n            };\n            check();\n        });\n    };\n    /**\n     * Returns if an imageUrl is an relative path\n     * @param imageUrl\n     */\n    ImageLoader.prototype.isImageUrlRelative = function (imageUrl) {\n        return !/^(https?|file):\\/\\/\\/?/i.test(imageUrl);\n    };\n    /**\n     * Add an item to the queue\n     * @param imageUrl\n     * @param resolve\n     * @param reject\n     */\n    ImageLoader.prototype.addItemToQueue = function (imageUrl, resolve, reject) {\n        this.queue.push({\n            imageUrl: imageUrl,\n            resolve: resolve,\n            reject: reject\n        });\n        this.processQueue();\n    };\n    /**\n     * Processes one item from the queue\n     */\n    ImageLoader.prototype.processQueue = function () {\n        var _this = this;\n        // make sure we can process items first\n        if (!this.canProcess)\n            return;\n        // increase the processing number\n        this.processing++;\n        // take the first item from queue\n        var currentItem = this.queue.splice(0, 1)[0];\n        if (this.currentlyProcessing[currentItem.imageUrl] === undefined) {\n            this.currentlyProcessing[currentItem.imageUrl] = new Promise(function (resolve, reject) {\n                // process more items concurrently if we can\n                if (_this.canProcess)\n                    _this.processQueue();\n                // function to call when done processing this item\n                // this will reduce the processing number\n                // then will execute this function again to process any remaining items\n                var done = function () {\n                    _this.processing--;\n                    _this.processQueue();\n                    if (_this.currentlyProcessing[currentItem.imageUrl] !== undefined) {\n                        delete _this.currentlyProcessing[currentItem.imageUrl];\n                    }\n                };\n                var error = function (e) {\n                    currentItem.reject();\n                    _this.throwError(e);\n                    done();\n                };\n                var localDir = _this.file.cacheDirectory + _this.config.cacheDirectoryName + '/';\n                var fileName = _this.createFileName(currentItem.imageUrl);\n                _this.http.get(currentItem.imageUrl, {\n                    responseType: 'blob',\n                    headers: _this.config.httpHeaders\n                }).subscribe(function (data) {\n                    _this.file.writeFile(localDir, fileName, data, { replace: true }).then(function (file) {\n                        if (_this.isCacheSpaceExceeded) {\n                            _this.maintainCacheSize();\n                        }\n                        _this.addFileToIndex(file).then(function () {\n                            _this.getCachedImagePath(currentItem.imageUrl).then(function (localUrl) {\n                                currentItem.resolve(localUrl);\n                                resolve();\n                                done();\n                                _this.maintainCacheSize();\n                            });\n                        });\n                    }).catch(function (e) {\n                        //Could not write image\n                        error(e);\n                    });\n                }, function (e) {\n                    //Could not get image via httpClient\n                    error(e);\n                });\n            });\n        }\n        else {\n            //Prevented same Image from loading at the same time\n            this.currentlyProcessing[currentItem.imageUrl].then(function () {\n                _this.getCachedImagePath(currentItem.imageUrl).then(function (localUrl) {\n                    currentItem.resolve(localUrl);\n                });\n            });\n        }\n    };\n    /**\n     * Initialize the cache service\n     * @param replace {boolean} Whether to replace the cache directory if it already exists\n     */\n    ImageLoader.prototype.initCache = function (replace) {\n        var _this = this;\n        this.concurrency = this.config.concurrency;\n        // create cache directories if they do not exist\n        this.createCacheDirectory(replace)\n            .catch(function (e) {\n            _this.throwError(e);\n            _this.isInit = true;\n        })\n            .then(function () { return _this.indexCache(); })\n            .then(function () {\n            _this.isCacheReady = true;\n            _this.isInit = true;\n        });\n    };\n    /**\n     * Adds a file to index.\n     * Also deletes any files if they are older than the set maximum cache age.\n     * @param file {FileEntry} File to index\n     * @returns {Promise<any>}\n     */\n    ImageLoader.prototype.addFileToIndex = function (file) {\n        var _this = this;\n        return new Promise(function (resolve, reject) { return file.getMetadata(resolve, reject); })\n            .then(function (metadata) {\n            if (_this.config.maxCacheAge > -1\n                && (Date.now() - metadata.modificationTime.getTime()) > _this.config.maxCacheAge) {\n                // file age exceeds maximum cache age\n                return _this.removeFile(file.name);\n            }\n            else {\n                // file age doesn't exceed maximum cache age, or maximum cache age isn't set\n                _this.currentCacheSize += metadata.size;\n                // add item to index\n                _this.cacheIndex.push({\n                    name: file.name,\n                    modificationTime: metadata.modificationTime,\n                    size: metadata.size\n                });\n                return Promise.resolve();\n            }\n        });\n    };\n    /**\n     * Indexes the cache if necessary\n     * @returns {any}\n     */\n    ImageLoader.prototype.indexCache = function () {\n        var _this = this;\n        this.cacheIndex = [];\n        return this.file.listDir(this.file.cacheDirectory, this.config.cacheDirectoryName)\n            .then(function (files) { return Promise.all(files.map(_this.addFileToIndex.bind(_this))); })\n            .then(function () {\n            // Sort items by date. Most recent to oldest.\n            _this.cacheIndex = _this.cacheIndex.sort(function (a, b) { return a > b ? -1 : a < b ? 1 : 0; });\n            _this.indexed = true;\n            return Promise.resolve();\n        })\n            .catch(function (e) {\n            _this.throwError(e);\n            return Promise.resolve();\n        });\n    };\n    /**\n     * This method runs every time a new file is added.\n     * It checks the cache size and ensures that it doesn't exceed the maximum cache size set in the config.\n     * If the limit is reached, it will delete old images to create free space.\n     */\n    ImageLoader.prototype.maintainCacheSize = function () {\n        var _this = this;\n        if (this.config.maxCacheSize > -1 && this.indexed) {\n            var maintain_1 = function () {\n                if (_this.currentCacheSize > _this.config.maxCacheSize) {\n                    // called when item is done processing\n                    var next_1 = function () {\n                        _this.currentCacheSize -= file_1.size;\n                        maintain_1();\n                    };\n                    // grab the first item in index since it's the oldest one\n                    var file_1 = _this.cacheIndex.splice(0, 1)[0];\n                    if (typeof file_1 == 'undefined')\n                        return maintain_1();\n                    // delete the file then process next file if necessary\n                    _this.removeFile(file_1.name)\n                        .then(function () { return next_1(); })\n                        .catch(function () { return next_1(); }); // ignore errors, nothing we can do about it\n                }\n            };\n            maintain_1();\n        }\n    };\n    /**\n     * Remove a file\n     * @param file {string} The name of the file to remove\n     */\n    ImageLoader.prototype.removeFile = function (file) {\n        var _this = this;\n        return this.file\n            .removeFile(this.file.cacheDirectory + this.config.cacheDirectoryName, file)\n            .then(function () {\n            if (_this.isWKWebView && !_this.isIonicWKWebView) {\n                return _this.file\n                    .removeFile(_this.file.tempDirectory + _this.config.cacheDirectoryName, file)\n                    .catch(function () {\n                    // Noop catch. Removing the files from tempDirectory might fail, as it is not persistent.\n                });\n            }\n        });\n    };\n    /**\n     * Get the local path of a previously cached image if exists\n     * @param url {string} The remote URL of the image\n     * @returns {Promise<string>} Returns a promise that resolves with the local path if exists, or rejects if doesn't exist\n     */\n    ImageLoader.prototype.getCachedImagePath = function (url) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            // make sure cache is ready\n            if (!_this.isCacheReady) {\n                return reject();\n            }\n            // if we're running with livereload, ignore cache and call the resource from it's URL\n            if (_this.isDevServer) {\n                return resolve(url);\n            }\n            // get file name\n            var fileName = _this.createFileName(url);\n            // get full path\n            var dirPath = _this.file.cacheDirectory + _this.config.cacheDirectoryName, tempDirPath = _this.file.tempDirectory + _this.config.cacheDirectoryName;\n            // check if exists\n            _this.file.resolveLocalFilesystemUrl(dirPath + '/' + fileName)\n                .then(function (fileEntry) {\n                // file exists in cache\n                if (_this.config.imageReturnType === 'base64') {\n                    // read the file as data url and return the base64 string.\n                    // should always be successful as the existence of the file\n                    // is alreay ensured\n                    _this.file\n                        .readAsDataURL(dirPath, fileName)\n                        .then(function (base64) {\n                        base64 = base64.replace('data:null', 'data:*/*');\n                        resolve(base64);\n                    })\n                        .catch(reject);\n                }\n                else if (_this.config.imageReturnType === 'uri') {\n                    // now check if iOS device & using WKWebView Engine.\n                    // in this case only the tempDirectory is accessible,\n                    // therefore the file needs to be copied into that directory first!\n                    if (_this.isIonicWKWebView) {\n                        // Use Ionic normalizeUrl to generate the right URL for Ionic WKWebView\n                        resolve(normalizeURL(fileEntry.nativeURL));\n                    }\n                    else if (_this.isWKWebView) {\n                        // check if file already exists in temp directory\n                        _this.file.resolveLocalFilesystemUrl(tempDirPath + '/' + fileName)\n                            .then(function (tempFileEntry) {\n                            // file exists in temp directory\n                            // return native path\n                            resolve(tempFileEntry.nativeURL);\n                        })\n                            .catch(function () {\n                            // file does not yet exist in the temp directory.\n                            // copy it!\n                            _this.file.copyFile(dirPath, fileName, tempDirPath, fileName)\n                                .then(function (tempFileEntry) {\n                                // now the file exists in the temp directory\n                                // return native path\n                                resolve(tempFileEntry.nativeURL);\n                            })\n                                .catch(reject);\n                        });\n                    }\n                    else {\n                        // return native path\n                        resolve(fileEntry.nativeURL);\n                    }\n                }\n            })\n                .catch(reject); // file doesn't exist\n        });\n    };\n    /**\n     * Throws a console error if debug mode is enabled\n     * @param args {any[]} Error message\n     */\n    ImageLoader.prototype.throwError = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (this.config.debugMode) {\n            args.unshift('ImageLoader Error: ');\n            console.error.apply(console, args);\n        }\n    };\n    /**\n     * Throws a console warning if debug mode is enabled\n     * @param args {any[]} Error message\n     */\n    ImageLoader.prototype.throwWarning = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (this.config.debugMode) {\n            args.unshift('ImageLoader Warning: ');\n            console.warn.apply(console, args);\n        }\n    };\n    /**\n     * Check if the cache directory exists\n     * @param directory {string} The directory to check. Either this.file.tempDirectory or this.file.cacheDirectory\n     * @returns {Promise<boolean|FileError>} Returns a promise that resolves if exists, and rejects if it doesn't\n     */\n    ImageLoader.prototype.cacheDirectoryExists = function (directory) {\n        return this.file.checkDir(directory, this.config.cacheDirectoryName);\n    };\n    /**\n     * Create the cache directories\n     * @param replace {boolean} override directory if exists\n     * @returns {Promise<DirectoryEntry|FileError>} Returns a promise that resolves if the directories were created, and rejects on error\n     */\n    ImageLoader.prototype.createCacheDirectory = function (replace) {\n        var _this = this;\n        if (replace === void 0) { replace = false; }\n        var cacheDirectoryPromise, tempDirectoryPromise;\n        if (replace) {\n            // create or replace the cache directory\n            cacheDirectoryPromise = this.file.createDir(this.file.cacheDirectory, this.config.cacheDirectoryName, replace);\n        }\n        else {\n            // check if the cache directory exists.\n            // if it does not exist create it!\n            cacheDirectoryPromise = this.cacheDirectoryExists(this.file.cacheDirectory)\n                .catch(function () { return _this.file.createDir(_this.file.cacheDirectory, _this.config.cacheDirectoryName, false); });\n        }\n        if (this.isWKWebView && !this.isIonicWKWebView) {\n            if (replace) {\n                // create or replace the temp directory\n                tempDirectoryPromise = this.file.createDir(this.file.tempDirectory, this.config.cacheDirectoryName, replace);\n            }\n            else {\n                // check if the temp directory exists.\n                // if it does not exist create it!\n                tempDirectoryPromise = this.cacheDirectoryExists(this.file.tempDirectory)\n                    .catch(function () { return _this.file.createDir(_this.file.tempDirectory, _this.config.cacheDirectoryName, false); });\n            }\n        }\n        else {\n            tempDirectoryPromise = Promise.resolve();\n        }\n        return Promise.all([cacheDirectoryPromise, tempDirectoryPromise]);\n    };\n    /**\n     * Creates a unique file name out of the URL\n     * @param url {string} URL of the file\n     * @returns {string} Unique file name\n     */\n    ImageLoader.prototype.createFileName = function (url) {\n        // hash the url to get a unique file name\n        return this.hashString(url).toString() + (this.config.fileNameCachedWithExtension ? this.getExtensionFromFileName(url) : '');\n    };\n    /**\n     * Converts a string to a unique 32-bit int\n     * @param string {string} string to hash\n     * @returns {number} 32-bit int\n     */\n    ImageLoader.prototype.hashString = function (string) {\n        var hash = 0, char;\n        if (string.length === 0)\n            return hash;\n        for (var i = 0; i < string.length; i++) {\n            char = string.charCodeAt(i);\n            hash = ((hash << 5) - hash) + char;\n            hash = hash & hash;\n        }\n        return hash;\n    };\n    /**\n     * extract extension from filename or url\n     *\n     * @param filename\n     * @returns {string}\n     */\n    ImageLoader.prototype.getExtensionFromFileName = function (filename) {\n        return filename.substr((~-filename.lastIndexOf('.') >>> 0) + 1) || this.config.fallbackFileNameCachedExtension;\n    };\n    return ImageLoader;\n}());\nexport { ImageLoader };\nImageLoader.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nImageLoader.ctorParameters = function () { return [\n    { type: ImageLoaderConfig, },\n    { type: File, },\n    { type: HttpClient, },\n    { type: Platform, },\n]; };\n//# sourceMappingURL=image-loader.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ionic-image-loader/dist/providers/image-loader.js\n// module id = 518\n// module chunks = 0 16","import { Component, ElementRef, EventEmitter, Input, Output, Renderer } from '@angular/core';\nimport { ImageLoader } from '../providers/image-loader';\nimport { ImageLoaderConfig } from '../providers/image-loader-config';\nvar propMap = {\n    display: 'display',\n    height: 'height',\n    width: 'width',\n    backgroundSize: 'background-size',\n    backgroundRepeat: 'background-repeat'\n};\nvar ImgLoader = (function () {\n    function ImgLoader(_element, _renderer, _imageLoader, _config) {\n        this._element = _element;\n        this._renderer = _renderer;\n        this._imageLoader = _imageLoader;\n        this._config = _config;\n        /**\n         * Fallback URL to load when the image url fails to load or does not exist.\n         */\n        this.fallbackUrl = this._config.fallbackUrl;\n        /**\n         * Whether to show a spinner while the image loads\n         */\n        this.spinner = this._config.spinnerEnabled;\n        /**\n         * Whether to show the fallback image instead of a spinner while the image loads\n         */\n        this.fallbackAsPlaceholder = this._config.fallbackAsPlaceholder;\n        this._useImg = this._config.useImg;\n        /**\n         * Attributes to pass through to img tag if _useImg == true\n         */\n        this.imgAttributes = [];\n        /**\n         * Enable/Disable caching\n         * @type {boolean}\n         */\n        this.cache = true;\n        /**\n         * Width of the image. This will be ignored if using useImg.\n         */\n        this.width = this._config.width;\n        /**\n         * Height of the image. This will be ignored if using useImg.\n         */\n        this.height = this._config.height;\n        /**\n         * Display type of the image. This will be ignored if using useImg.\n         */\n        this.display = this._config.display;\n        /**\n         * Background size. This will be ignored if using useImg.\n         */\n        this.backgroundSize = this._config.backgroundSize;\n        /**\n         * Background repeat. This will be ignored if using useImg.\n         */\n        this.backgroundRepeat = this._config.backgroundRepeat;\n        /**\n         * Name of the spinner\n         */\n        this.spinnerName = this._config.spinnerName;\n        /**\n         * Color of the spinner\n         */\n        this.spinnerColor = this._config.spinnerColor;\n        /**\n         * Notify on image load..\n         */\n        this.load = new EventEmitter();\n        /**\n         * Indicates if the image is still loading\n         * @type {boolean}\n         */\n        this.isLoading = true;\n    }\n    Object.defineProperty(ImgLoader.prototype, \"useImg\", {\n        /**\n         * Use <img> tag\n         */\n        set: function (val) {\n            this._useImg = val !== false;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImgLoader.prototype, \"noCache\", {\n        /**\n         * Convenience attribute to disable caching\n         * @param val\n         */\n        set: function (val) {\n            this.cache = val !== false;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImgLoader.prototype, \"src\", {\n        get: function () {\n            return this._src;\n        },\n        /**\n         * The URL of the image to load.\n         */\n        set: function (imageUrl) {\n            this._src = this.processImageUrl(imageUrl);\n            this.updateImage(this._src);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ;\n    ImgLoader.prototype.ngOnInit = function () {\n        if (this.fallbackAsPlaceholder && this.fallbackUrl) {\n            this.setImage(this.fallbackUrl, false);\n        }\n        if (!this.src) {\n            // image url was not passed\n            // this can happen when [src] is set to a variable that turned out to be undefined\n            // one example could be a list of users with their profile pictures\n            // in this case, it would be useful to use the fallback image instead\n            // if fallbackUrl was used as placeholder we do not need to set it again\n            if (!this.fallbackAsPlaceholder && this.fallbackUrl) {\n                // we're not going to cache the fallback image since it should be locally saved\n                this.setImage(this.fallbackUrl);\n            }\n            else {\n                this.isLoading = false;\n            }\n        }\n    };\n    ImgLoader.prototype.updateImage = function (imageUrl) {\n        var _this = this;\n        this._imageLoader.getImagePath(imageUrl)\n            .then(function (imageUrl) { return _this.setImage(imageUrl); })\n            .catch(function (error) { return _this.setImage(_this.fallbackUrl || imageUrl); });\n    };\n    /**\n     * Gets the image URL to be loaded and disables caching if necessary\n     * @returns {string}\n     */\n    ImgLoader.prototype.processImageUrl = function (imageUrl) {\n        if (this.cache === false) {\n            // need to disable caching\n            if (imageUrl.indexOf('?') === -1) {\n                imageUrl += '?';\n            }\n            if (['&', '?'].indexOf(imageUrl.charAt(imageUrl.length)) === -1) {\n                imageUrl += '&';\n            }\n            // append timestamp at the end to make URL unique\n            imageUrl += 'cache_buster=' + Date.now();\n        }\n        return imageUrl;\n    };\n    /**\n     * Set the image to be displayed\n     * @param imageUrl {string} image src\n     * @param stopLoading {boolean} set to true to mark the image as loaded\n     */\n    ImgLoader.prototype.setImage = function (imageUrl, stopLoading) {\n        var _this = this;\n        if (stopLoading === void 0) { stopLoading = true; }\n        this.isLoading = !stopLoading;\n        if (this._useImg) {\n            // Using <img> tag\n            if (!this.element) {\n                // create img element if we dont have one\n                this.element = this._renderer.createElement(this._element.nativeElement, 'img');\n            }\n            // set it's src\n            this._renderer.setElementAttribute(this.element, 'src', imageUrl);\n            // if imgAttributes are defined, add them to our img element\n            this.imgAttributes.forEach(function (attribute) {\n                _this._renderer.setElementAttribute(_this.element, attribute.element, attribute.value);\n            });\n            if (this.fallbackUrl && !this._imageLoader.nativeAvailable) {\n                this._renderer.listen(this.element, 'error', function () { return _this._renderer.setElementAttribute(_this.element, 'src', _this.fallbackUrl); });\n            }\n        }\n        else {\n            // Not using <img> tag\n            this.element = this._element.nativeElement;\n            for (var prop in propMap) {\n                if (this[prop]) {\n                    this._renderer.setElementStyle(this.element, propMap[prop], this[prop]);\n                }\n            }\n            this._renderer.setElementStyle(this.element, 'background-image', 'url(\\'' + (imageUrl || this.fallbackUrl) + '\\')');\n        }\n        this.load.emit(this);\n    };\n    return ImgLoader;\n}());\nexport { ImgLoader };\nImgLoader.decorators = [\n    { type: Component, args: [{\n                selector: 'img-loader',\n                template: '<ion-spinner *ngIf=\"spinner && isLoading && !fallbackAsPlaceholder\" [name]=\"spinnerName\" [color]=\"spinnerColor\"></ion-spinner>' +\n                    '<ng-content></ng-content>',\n                styles: ['ion-spinner { float: none; margin-left: auto; margin-right: auto; display: block; }']\n            },] },\n];\n/** @nocollapse */\nImgLoader.ctorParameters = function () { return [\n    { type: ElementRef, },\n    { type: Renderer, },\n    { type: ImageLoader, },\n    { type: ImageLoaderConfig, },\n]; };\nImgLoader.propDecorators = {\n    'fallbackUrl': [{ type: Input, args: ['fallback',] },],\n    'spinner': [{ type: Input },],\n    'fallbackAsPlaceholder': [{ type: Input },],\n    'useImg': [{ type: Input },],\n    'imgAttributes': [{ type: Input, args: ['imgAttributes',] },],\n    'noCache': [{ type: Input },],\n    'cache': [{ type: Input },],\n    'src': [{ type: Input },],\n    'width': [{ type: Input },],\n    'height': [{ type: Input },],\n    'display': [{ type: Input },],\n    'backgroundSize': [{ type: Input },],\n    'backgroundRepeat': [{ type: Input },],\n    'spinnerName': [{ type: Input },],\n    'spinnerColor': [{ type: Input },],\n    'load': [{ type: Output },],\n};\n//# sourceMappingURL=img-loader.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ionic-image-loader/dist/components/img-loader.js\n// module id = 519\n// module chunks = 0 16","export * from './image-loader.module';\nexport * from './components/img-loader';\nexport * from './providers/image-loader-config';\nexport * from './providers/image-loader';\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ionic-image-loader/dist/index.js\n// module id = 520\n// module chunks = 0 16","import { NgModule } from '@angular/core';\nimport { ImgLoader } from './components/img-loader';\nimport { ImageLoader } from './providers/image-loader';\nimport { ImageLoaderConfig } from './providers/image-loader-config';\nimport { IonicModule } from 'ionic-angular';\nimport { File } from '@ionic-native/file';\nimport { HttpClientModule } from '@angular/common/http';\nvar IonicImageLoader = (function () {\n    function IonicImageLoader() {\n    }\n    IonicImageLoader.forRoot = function () {\n        return {\n            ngModule: IonicImageLoader,\n            providers: [\n                ImageLoaderConfig,\n                ImageLoader,\n                File\n            ]\n        };\n    };\n    return IonicImageLoader;\n}());\nexport { IonicImageLoader };\nIonicImageLoader.decorators = [\n    { type: NgModule, args: [{\n                declarations: [\n                    ImgLoader\n                ],\n                imports: [\n                    IonicModule,\n                    HttpClientModule\n                ],\n                exports: [\n                    ImgLoader\n                ]\n            },] },\n];\n/** @nocollapse */\nIonicImageLoader.ctorParameters = function () { return []; };\n//# sourceMappingURL=image-loader.module.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ionic-image-loader/dist/image-loader.module.js\n// module id = 521\n// module chunks = 0 16","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar first_1 = require('../../operator/first');\nObservable_1.Observable.prototype.first = first_1.first;\n//# sourceMappingURL=first.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/operator/first.js\n// module id = 522\n// module chunks = 0 16","\"use strict\";\nvar first_1 = require('../operators/first');\n/**\n * Emits only the first value (or the first value that meets some condition)\n * emitted by the source Observable.\n *\n * <span class=\"informal\">Emits only the first value. Or emits only the first\n * value that passes some test.</span>\n *\n * <img src=\"./img/first.png\" width=\"100%\">\n *\n * If called with no arguments, `first` emits the first value of the source\n * Observable, then completes. If called with a `predicate` function, `first`\n * emits the first value of the source that matches the specified condition. It\n * may also take a `resultSelector` function to produce the output value from\n * the input value, and a `defaultValue` to emit in case the source completes\n * before it is able to emit a valid value. Throws an error if `defaultValue`\n * was not provided and a matching element is not found.\n *\n * @example <caption>Emit only the first click that happens on the DOM</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first();\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Emits the first click that happens on a DIV</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link take}\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n * An optional function called with each item to test for condition matching.\n * @param {function(value: T, index: number): R} [resultSelector] A function to\n * produce the value on the output Observable based on the values\n * and the indices of the source Observable. The arguments passed to this\n * function are:\n * - `value`: the value that was emitted on the source.\n * - `index`: the \"index\" of the value from the source.\n * @param {R} [defaultValue] The default value emitted in case no valid value\n * was found on the source.\n * @return {Observable<T|R>} An Observable of the first item that matches the\n * condition.\n * @method first\n * @owner Observable\n */\nfunction first(predicate, resultSelector, defaultValue) {\n    return first_1.first(predicate, resultSelector, defaultValue)(this);\n}\nexports.first = first;\n//# sourceMappingURL=first.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/first.js\n// module id = 523\n// module chunks = 0 16","import { Component } from '@angular/core';\nimport { IonicPage, ModalController, NavController } from 'ionic-angular';\nimport { HttpClient } from '@angular/common/http';\n\nimport { Database, Api } from '../../providers';\n\n@IonicPage()\n@Component({\n  selector: 'page-plants',\n  templateUrl: 'plants.html'\n})\nexport class PlantsPage {\n  Object = Object;\n  filters;\n  plants;\n  searching = false;\n\n  constructor(public navCtrl: NavController, public database: Database, public api: Api, public modalCtrl: ModalController, public http: HttpClient) {\n\n    this.filters = {\n      cycle: '',\n      stratum: '',\n      search: '',\n      page: 1\n    }\n\n    this.list();\n\n  }\n\n  list() {\n    this.searching = true\n    this.database.query('plants', this.filters).then(res => {\n      if (!this.plants) {\n        this.plants = []\n      }\n      this.plants = this.plants.concat(res)\n      this.searching = false\n    })\n  }\n\n  showMore(infiniteScroll) {\n    this.filters.page += 1\n    this.list()\n    infiniteScroll.complete();\n  }\n\n  search() {\n    this.plants = []\n    this.filters.page = 1\n    this.list();\n  }\n\n  add() {\n    this.navCtrl.push('PlantFormPage');\n  }\n\n  open(id) {\n    this.navCtrl.push('PlantPage', {\n      id: id\n    });\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/pages/plants/plants.ts"],"sourceRoot":""}